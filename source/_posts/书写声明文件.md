---
title: 书写声明文件
tags: TS声明文件
categories: TS
keywords: TS声明文件
description: >-
  一般来讲，你*组织*声明文件的方式取决于库是如何被使用的。 在JavaScript中一个库有很多使用方式，这就需要你书写声明文件去匹配它们。
  这篇指南涵盖了如何识别常见库的模式，和怎样书写符合相应模式的声明文件。
top_img: "https://hawking-img.oss-cn-hangzhou.aliyuncs.com/BlogPic/v2-7cb0dbd256c6f738c73e60c9620a5470_1440w.jpg"
cover: "https://hawking-img.oss-cn-hangzhou.aliyuncs.com/BlogPic/20210915231539_e0f2a.jpeg"
abbrlink: 36cd53fe
date: 2022-09-2 23:48:45
---

## 结构

> 一般来讲，你*组织*声明文件的方式取决于库是如何被使用的。 在 JavaScript 中一个库有很多使用方式，这就需要你书写声明文件去匹配它们。 这篇指南涵盖了如何识别常见库的模式，和怎样书写符合相应模式的声明文件。

### 识别库的类型

#### 全局库

*全局*库是指能在全局命名空间下访问的（例如：不需要使用任何形式的`import`）。 许多库都是简单的暴露出一个或多个全局变量。

### 普通类型

> *应该*使用类型`number`，`string`，and `boolean`。*不要*使用如下类型`Number`，`String`，`Boolean`或`Object`。 这些类型指的是非原始的装盒对象，它们几乎没在 JavaScript 代码里正确地使用过。

```TypeScript
/* 错误 */
function reverse(s: String): String;
```

### 回调函数的类型

> *不要*为返回值被忽略的回调函数设置一个`any`类型的返回值类型：*应该*给返回值被忽略的回调函数设置`void`类型的返回值类型：*不要*在回调函数里使用可选参数除非你真的要这么做

```TypeScript
/* 错误 */
function fn(x: () => any) {
    x();
}
```

### 重载回调函数

> *不要*因为回调函数参数个数不同而写不同的重载：*应该*只使用最大参数个数写一个重载：

_为什么_：回调函数总是可以忽略某个参数的，因此没必要为参数少的情况写重载。 参数少的回调函数首先允许错误类型的函数被传入，因为它们匹配第一个重载。

```TypeScript
/* 错误 */
declare function beforeAll(action: () => void, timeout?: number): void;
declare function beforeAll(action: (done: DoneFn) => void, timeout?: number): void;
```

### 函数重载

> *不要*把一般的重载放在精确的重载前面：*应该*排序重载令精确的排在一般的之前：

_为什么_：TypeScript 会选择*第一个匹配到的重载*当解析函数调用的时候。 当前面的重载比后面的“普通”，那么后面的被隐藏了不会被调用。

```TypeScript
/* 错误 */
declare function fn(x: any): any;
declare function fn(x: HTMLElement): number;
declare function fn(x: HTMLDivElement): string;

var myElem: HTMLDivElement;
var x = fn(myElem); // x: any, wat?
```

> *不要*为仅在末尾参数不同时写不同的重载：*应该*尽可能使用可选参数：

```TypeScript
/* 错误 */
interface Example {
    diff(one: string): number;
    diff(one: string, two: string): number;
    diff(one: string, two: string, three: boolean): number;
}
```

## 举例

### 全局变量

> 使用`declare var`声明变量。 如果变量是只读的，那么可以使用`declare const`。 你还可以使用`declare let`如果变量拥有块级作用域。

```TypeScript
/** 组件总数 */
declare var foo: number;
```

### 全局函数

> 使用`declare function`声明函数。

```TypeScript
declare function greet(greeting: string): void;
```

### 带属性的对象

> 全局变量`myLib`包含一个`makeGreeting`函数， 还有一个属性`numberOfGreetings`指示目前为止欢迎数量。

```TypeScript
let result = myLib.makeGreeting("hello, world");
console.log("The computed greeting is:" + result);

let count = myLib.numberOfGreetings;
```

### 函数重载

> `getWidget`函数接收一个数字，返回一个组件，或接收一个字符串并返回一个组件数组。

```TypeScript
let x: Widget = getWidget(43);

let arr: Widget[] = getWidget("all of them");
```

### 可重用接口

> 当指定一个欢迎词时，你必须传入一个`GreetingSettings`对象。 这个对象具有以下几个属性：

1. - greeting：必需的字符串

2. - duration: 可靠的时长（毫秒表示）

3. - color: 可选字符串，比如‘#ff00ff’

```TypeScript
greet({
  greeting: "hello world",
  duration: 4000
});
```

### 可重用类型别名

在任何需要欢迎词的地方，你可以提供一个`string`，一个返回`string`的函数或一个`Greeter`实例。

```TypeScript
function getGreeting() {
    return "howdy";
}
class MyGreeter extends Greeter { }

greet("hello");
greet(getGreeting);
greet(new MyGreeter());
```

### 组织类型

`greeter`对象能够记录到文件或显示一个警告。 你可以为`.log(...)`提供 LogOptions 和为`.alert(...)`提供选项。

```TypeScript
const g = new Greeter("Hello");
g.log({ verbose: true });
g.alert({ modal: false, title: "Current Greeting" });
```

```TypeScript
declare namespace GreetingLib {
    interface LogOptions {
        verbose?: boolean;
    }
    interface AlertOptions {
        modal: boolean;
        title?: string;
        color?: string;
    }
}

```

### 类

> 你可以通过实例化`Greeter`对象来创建欢迎词，或者继承`Greeter`对象来自定义欢迎词。

使用`declare class`描述一个类或像类一样的对象。 类可以有属性和方法，就和构造函数一样。

```TypeScript
const myGreeter = new Greeter("hello, world");
myGreeter.greeting = "howdy";
myGreeter.showGreeting();

class SpecialGreeter extends Greeter {
    constructor() {
        super("Very special greetings");
    }
}
```

## 深入

### 类型

> 如果你正在阅读这篇指南，你可能已经大概了解 TypeScript 里的类型指是什么。 明确一下，*类型*通过以下方式引入：

- 类型别名声明（`type sn = number | string;`）

- 接口声明（`interface I { x: number[]; }`）

- 类声明（`class C { }`）

- 枚举声明（`enum E { A, B, C }`）

- 指向某个类型的`import`声明

### 值

> 与类型相比，你可能已经理解了什么是值。 值是运行时名字，可以在表达式里引用。 比如`let x = 5;`创建一个名为`x`的值。

- `let`，`const`，和`var`声明

- 包含值的`namespace`或`module`声明

- `enum`声明

- `class`声明

- 指向值的`import`声明

- `function`声明

### 命名空间

> 类型可以存在于*命名空间*里。 比如，有这样的声明`let x: A.B.C`， 我们就认为`C`类型来自`A.B`命名空间。
